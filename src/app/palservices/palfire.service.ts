// src/app/services/firestore.service.ts

import { inject, Injectable } from '@angular/core';
// ADDED onSnapshot for manual mapping of collection data
import { Firestore, collection, collectionData, doc, docData, addDoc, updateDoc, deleteDoc, setDoc, CollectionReference, DocumentReference, query, QueryConstraint, onSnapshot } from '@angular/fire/firestore';
import { Observable } from 'rxjs';

/**
 * Interface for any document stored in Firestore.
 * NOTE: releaseDate and stockDate are set to Date type to handle Firestore Timestamps.
 */
export interface FirestoreDoc {
    id: string; // Document ID (usually same as Firestore doc ID)
    currentStock: string;
    date_epoch: number;
    do: number;
    nh4: number;
    ph: number;
    releaseDate: Date; // Assuming this is stored as a Firestore Timestamp
    salinity: number;
    stockDate: Date; // Assuming this is stored as a Firestore Timestamp
    tankId: string;
    temp_c: number;
    timestamp: string; // Keeping as string as per your screenshot
    turbidity: number;
    waterlevel: number;
}

@Injectable({
    providedIn: 'root'
})
export class FirestoreService {
    // Use the modern inject() function to get the Firestore instance
    private firestore: Firestore = inject(Firestore);

    /**
     * Gets a reference to a Firestore collection with strong typing.
     */
    private getCollectionRef<T>(path: string): CollectionReference<T> {
        return collection(this.firestore, path) as CollectionReference<T>;
    }

    /**
     * Gets a reference to a Firestore document with strong typing.
     */
    private getDocumentRef<T>(path: string): DocumentReference<T> {
        return doc(this.firestore, path) as DocumentReference<T>;
    }

    // ------------------------------------------------------------------
    // 1. CREATE (C)
    // ------------------------------------------------------------------

    /**
     * Adds a new document to a collection. The ID will be auto-generated by Firestore.
     */
    async addDocument<T extends FirestoreDoc>(path: string, data: Omit<T, 'id'>): Promise<DocumentReference<Omit<T, 'id'>>> {
        const colRef = this.getCollectionRef<Omit<T, 'id'>>(path);
        // Cast data to 'any' for the underlying Firestore operation
        return addDoc(colRef, data as any);
    }

    /**
     * Sets a document with a specific ID. Can be used for creation or full overwrite.
     */
    async setDocument<T extends FirestoreDoc>(path: string, data: Omit<T, 'id'>): Promise<void> {
        const docRef = this.getDocumentRef<Omit<T, 'id'>>(path);
        // Cast data to 'any' for the underlying Firestore operation
        return setDoc(docRef, data as any);
    }

    // ------------------------------------------------------------------
    // 2. READ (R)
    // ------------------------------------------------------------------

    /**
     * Retrieves a single document by its full path in real-time.
     */
    getDocument<T extends FirestoreDoc>(path: string): Observable<T> {
        const docRef = this.getDocumentRef<T>(path);
        // docData provides the document data and automatically includes the ID by default.
        return docData(docRef, { idField: 'id' }) as Observable<T>;
    }

    /**
     * Retrieves a collection of documents in real-time.
     * * REVISION: Switched from collectionData to manual onSnapshot mapping for maximum reliability.
     * This guarantees that the document data is extracted correctly and merged with the ID.
     */
    getCollection<T extends FirestoreDoc>(path: string, ...constraints: QueryConstraint[]): Observable<T[]> {
        const colRef = this.getCollectionRef<T>(path);
        const q = constraints.length > 0 ? query(colRef, ...constraints) : colRef;

        return new Observable<T[]>((subscriber) => {
            // Setup the real-time listener using onSnapshot
            const unsubscribe = onSnapshot(
                q as any,
                (snapshot: { docs: any[] }) => {
                    const data = snapshot.docs.map((doc) => {
                        // Manually extract the data and merge the document ID
                        return { id: doc.id, ...doc.data() } as T;
                    });
                    subscriber.next(data);
                },
                (error) => {
                    subscriber.error(error);
                }
            );

            // Return the unsubscribe function for cleanup when the Observable is unsubscribed
            return () => unsubscribe();
        });
    }

    // ------------------------------------------------------------------
    // 3. UPDATE (U)
    // ------------------------------------------------------------------

    /**
     * Updates specific fields of an existing document.
     */
    async updateDocument<T extends FirestoreDoc>(path: string, data: Partial<Omit<T, 'id'>>): Promise<void> {
        const docRef = this.getDocumentRef<T>(path);
        return updateDoc(docRef, data);
    }

    // ------------------------------------------------------------------
    // 4. DELETE (D)
    // ------------------------------------------------------------------

    /**
     * Deletes a document by its full path.
     */
    async deleteDocument(path: string): Promise<void> {
        const docRef = this.getDocumentRef<any>(path);
        return deleteDoc(docRef);
    }
}
